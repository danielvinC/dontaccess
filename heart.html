<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Sorry iemmmm</title>
  <style>
    html, body { height: 100%; margin: 0; overflow: hidden;
      background: radial-gradient(1200px 900px at 50% 35%, #1b1026 0%, #05020a 55%, #000 100%);
    }
    canvas { display:block; }

    #hud{
      position: fixed; left: 16px; bottom: 14px; z-index: 10;
      font: 12px/1.35 system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      color: rgba(255,255,255,.78);
      padding: 10px 12px;
      background: rgba(0,0,0,.25);
      border: 1px solid rgba(255,255,255,.10);
      border-radius: 12px;
      backdrop-filter: blur(8px);
      user-select: none;
    }
    #hud b { color: rgba(255,255,255,.95); font-weight: 650; }

    #centerText{
      position: fixed; inset: 0; z-index: 9;
      display: grid; place-items: center;
      pointer-events: none;
      font: italic 700 42px/1.05 ui-serif, Georgia, "Times New Roman", serif;
      color: rgba(255, 92, 164, 0.92);
      text-shadow: 0 0 18px rgba(255, 92, 164, 0.20);
      letter-spacing: 0.5px;
    }
  </style>

  <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
      }
    }
  </script>
</head>

<body>
  <div id="hud">
    <b>Chúc em vui vẻ nhớ ^^ Xin lỗi đã để em chờ
  </div>
  <div id="centerText">Vũ Linh Hà</div>

  <script type="module">
    import * as THREE from "three";
    import { OrbitControls } from "three/addons/controls/OrbitControls.js";
    import { EffectComposer } from "three/addons/postprocessing/EffectComposer.js";
    import { RenderPass } from "three/addons/postprocessing/RenderPass.js";
    import { UnrealBloomPass } from "three/addons/postprocessing/UnrealBloomPass.js";
    import { MeshSurfaceSampler } from "three/addons/math/MeshSurfaceSampler.js";

    // ----------------------------
    // Tunables
    // ----------------------------
    const SETTINGS = {
      look: {
        exposure: 0.82,
        fogDensity: 0.045
      },
      bloom: {
        strength: 2.5,
        radius: 0.95,
        threshold: 0.02
      },
      heart: {
        scale: 2.25,
        tiltX: Math.PI * 0.05,
        // base yaw to "turn head" left/right. Adjust as you like:
        baseYaw: Math.PI * 0.25
      },
      particles: {
        count: 9000,
        life: 2.2,
        speed: 2.2,
        effect: -1.3,
        sizePx: 18.0,
        swirl: 0.55,
        alpha: 0.85
      },
      stars: {
        count: 2000,
        opacity: 0.35
      },
      colors: {
        heart:    0xffa3d7,  // lighter pink body
        aura:     0xffd1ec,  // very light pink glow
        particle: 0xffb8e3,  // soft pink particles
        emissive: 0x3a001f   // deep but softer emissive base
      }
    };

    // ----------------------------
    // Renderer
    // ----------------------------
    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = SETTINGS.look.exposure;
    document.body.appendChild(renderer.domElement);

    // ----------------------------
    // Scene / Camera
    // ----------------------------
    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x07030c, SETTINGS.look.fogDensity);

    const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 250);
    camera.position.set(0, 2.2, 9.5);

    // ----------------------------
    // Controls
    // ----------------------------
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.06;
    controls.minDistance = 4.5;
    controls.maxDistance = 18;
    controls.target.set(0, 0.9, 0);

    window.addEventListener("dblclick", () => {
      controls.target.set(0, 0.9, 0);
      camera.position.set(0, 2.2, 9.5);
      controls.update();
    });

    // ----------------------------
    // Lights
    // ----------------------------
    scene.add(new THREE.AmbientLight(0xffffff, 0.08));

    const key = new THREE.DirectionalLight(0xffd6ea, 0.75);
    key.position.set(6, 10, 6);
    scene.add(key);

    const rim = new THREE.DirectionalLight(0x7bd3ff, 0.35);
    rim.position.set(-8, 6, -6);
    scene.add(rim);

    const pulseLight = new THREE.PointLight(0xff2d7a, 1.2, 35, 2.0);
    pulseLight.position.set(0, 1.0, 3.0);
    scene.add(pulseLight);

    // ----------------------------
    // Heart Geometry (solid)
    // ----------------------------
    function makeHeartShape() {
      const s = new THREE.Shape();
      s.moveTo(0, 1.2);
      s.bezierCurveTo(0, 0.35, -1.15, 0.35, -1.15, 1.2);
      s.bezierCurveTo(-1.15, 2.0, -0.35, 2.55, 0, 3.0);
      s.bezierCurveTo(0.35, 2.55, 1.15, 2.0, 1.15, 1.2);
      s.bezierCurveTo(1.15, 0.35, 0, 0.35, 0, 1.2);
      return s;
    }

    const heartShape = makeHeartShape();
    const heartGeo = new THREE.ExtrudeGeometry(heartShape, {
      depth: 0.85,
      steps: 2,
      bevelEnabled: true,
      bevelThickness: 0.28,
      bevelSize: 0.22,
      bevelSegments: 10
    });

    // Center
    heartGeo.computeBoundingBox();
    const bb = heartGeo.boundingBox;
    const center = new THREE.Vector3();
    bb.getCenter(center);
    heartGeo.translate(-center.x, -center.y, -center.z);

    const heartMat = new THREE.MeshPhysicalMaterial({
      color: SETTINGS.colors.heart,
      metalness: 0.32,
      roughness: 0.18,
      clearcoat: 1.0,
      clearcoatRoughness: 0.06,
      emissive: SETTINGS.colors.emissive,
      emissiveIntensity: 0.55
    });

    const heart = new THREE.Mesh(heartGeo, heartMat);
    heart.scale.setScalar(SETTINGS.heart.scale);
    scene.add(heart);

    // Aura shell
    const aura = new THREE.Mesh(
      heartGeo,
      new THREE.MeshBasicMaterial({
        color: SETTINGS.colors.aura,
        transparent: true,
        opacity: 0.10,
        depthWrite: false
      })
    );
    aura.scale.copy(heart.scale).multiplyScalar(1.035);
    scene.add(aura);

    // ----------------------------
    // Base orientation ("turn head")
    // - Flip upright: Z = PI (fix the upside-down look you had)
    // - Turn left/right: Y = baseYaw
    // ----------------------------
    const HEART_BASE = new THREE.Euler(
      SETTINGS.heart.tiltX,  // tilt
      SETTINGS.heart.baseYaw,// yaw (turn head)
      Math.PI                // flip 180° so point is DOWN
    );
    heart.rotation.copy(HEART_BASE);
    aura.rotation.copy(HEART_BASE);

    // ----------------------------
    // Surface sampler (emit from heart surface)
    // ----------------------------
    const sampler = new MeshSurfaceSampler(heart).build();

    // ----------------------------
    // Particles (GPU points + CPU sim)
    // ----------------------------
    const N = SETTINGS.particles.count;

    const pos = new Float32Array(N * 3);
    const vel = new Float32Array(N * 3);
    const acc = new Float32Array(N * 3);
    const birth = new Float32Array(N);

    const pGeo = new THREE.BufferGeometry();
    pGeo.setAttribute("position", new THREE.BufferAttribute(pos, 3));
    pGeo.setAttribute("aBirth", new THREE.BufferAttribute(birth, 1));

    const uniforms = {
      uTime:       { value: 0 },
      uLife:       { value: SETTINGS.particles.life },
      uColor:      { value: new THREE.Color(SETTINGS.colors.particle) },
      uSize:       { value: SETTINGS.particles.sizePx },
      uPixelRatio: { value: renderer.getPixelRatio() },
      uAlphaMul:   { value: SETTINGS.particles.alpha }
    };

    const pMat = new THREE.ShaderMaterial({
      uniforms,
      transparent: true,
      depthWrite: false,
      blending: THREE.AdditiveBlending,
      vertexShader: `
        attribute float aBirth;
        uniform float uTime;
        uniform float uLife;
        uniform float uSize;
        uniform float uPixelRatio;
        varying float vAlpha;

        float easeOutCubic(float t){
          t = clamp(t, 0.0, 1.0);
          return 1.0 - pow(1.0 - t, 3.0);
        }

        void main() {
          float age = uTime - aBirth;
          float t = age / uLife;

          vAlpha = 1.0 - clamp(t, 0.0, 1.0);

          vec4 mv = modelViewMatrix * vec4(position, 1.0);
          gl_Position = projectionMatrix * mv;

          float grow = 0.65 + 0.55 * easeOutCubic(1.0 - abs(2.0 * clamp(t,0.0,1.0) - 1.0));
          float dist = max(0.001, -mv.z);
          gl_PointSize = (uSize * uPixelRatio * grow) * (8.0 / dist);
        }
      `,
      fragmentShader: `
        uniform vec3  uColor;
        uniform float uAlphaMul;
        varying float vAlpha;

        void main() {
          vec2 p = gl_PointCoord * 2.0 - 1.0;
          float r2 = dot(p, p);

          float alpha = smoothstep(1.0, 0.55, 1.0 - r2);
          alpha *= vAlpha * uAlphaMul;

          if(alpha <= 0.001) discard;

          float core = smoothstep(0.85, 0.0, r2);
          vec3 col = uColor * (0.30 + 0.55 * core);

          gl_FragColor = vec4(col, alpha);
        }
      `
    });

    const particlePoints = new THREE.Points(pGeo, pMat);
    scene.add(particlePoints);

    // helper vectors
    const tmpPos = new THREE.Vector3();
    const tmpNrm = new THREE.Vector3();
    const tmpV   = new THREE.Vector3();
    const up     = new THREE.Vector3(0, 1, 0);

    function respawn(i, now, beatScale) {
      sampler.sample(tmpPos, tmpNrm);

      pos[i*3+0] = tmpPos.x;
      pos[i*3+1] = tmpPos.y;
      pos[i*3+2] = tmpPos.z;

      tmpV.copy(tmpNrm).normalize().multiplyScalar(
        SETTINGS.particles.speed * (0.85 + 0.3*Math.random()) * beatScale
      );

      const swirl = tmpNrm.clone().cross(up);
      if (swirl.lengthSq() > 1e-6) {
        swirl.normalize().multiplyScalar((Math.random()*2 - 1) * SETTINGS.particles.swirl);
        tmpV.add(swirl);
      }

      vel[i*3+0] = tmpV.x;
      vel[i*3+1] = tmpV.y;
      vel[i*3+2] = tmpV.z;

      acc[i*3+0] = tmpV.x * SETTINGS.particles.effect;
      acc[i*3+1] = tmpV.y * SETTINGS.particles.effect;
      acc[i*3+2] = tmpV.z * SETTINGS.particles.effect;

      birth[i] = now;
    }

    // prefill pool
    const clock = new THREE.Clock();
    for (let i = 0; i < N; i++) {
      respawn(i, -Math.random() * SETTINGS.particles.life, 1.0);
    }
    pGeo.attributes.position.needsUpdate = true;
    pGeo.attributes.aBirth.needsUpdate = true;

    // ----------------------------
    // Starfield
    // ----------------------------
    const starCount = SETTINGS.stars.count;
    const starGeo = new THREE.BufferGeometry();
    const starPos = new Float32Array(starCount * 3);

    for (let i = 0; i < starCount; i++) {
      const r = THREE.MathUtils.randFloat(12, 55);
      const theta = Math.random() * Math.PI * 2;
      const phi = Math.acos(THREE.MathUtils.randFloat(-1, 1));
      starPos[i * 3 + 0] = r * Math.sin(phi) * Math.cos(theta);
      starPos[i * 3 + 1] = r * Math.cos(phi);
      starPos[i * 3 + 2] = r * Math.sin(phi) * Math.sin(theta);
    }
    starGeo.setAttribute("position", new THREE.BufferAttribute(starPos, 3));

    const stars = new THREE.Points(
      starGeo,
      new THREE.PointsMaterial({
        color: 0xffffff,
        size: 0.045,
        sizeAttenuation: true,
        transparent: true,
        opacity: SETTINGS.stars.opacity
      })
    );
    scene.add(stars);

    // ----------------------------
    // Postprocessing (Bloom)
    // ----------------------------
    const composer = new EffectComposer(renderer);
    composer.addPass(new RenderPass(scene, camera));
    const bloom = new UnrealBloomPass(
      new THREE.Vector2(window.innerWidth, window.innerHeight),
      SETTINGS.bloom.strength,
      SETTINGS.bloom.radius,
      SETTINGS.bloom.threshold
    );
    composer.addPass(bloom);

    // ----------------------------
    // Animation
    // ----------------------------
    function tick() {
      const t = clock.getElapsedTime();
      uniforms.uTime.value = t;

      const beat = 1.0 + 0.04 * Math.sin(t * 3.2) + 0.015 * Math.sin(t * 6.4);

      heart.scale.setScalar(SETTINGS.heart.scale * beat);
      aura.scale.setScalar(SETTINGS.heart.scale * beat * 1.035);

      const glow = 0.45 + 0.55 * (0.5 + 0.5 * Math.sin(t * 3.2));
      heart.material.emissiveIntensity = 0.35 + 0.55 * glow;
      pulseLight.intensity = 0.7 + 1.0 * glow;

      // Keep base orientation, spin around Y
      heart.rotation.set(HEART_BASE.x, HEART_BASE.y + t * 0.55, HEART_BASE.z);
      aura.rotation.copy(heart.rotation);

      // particles sim
      const dt = Math.min(clock.getDelta(), 0.033);
      const life = SETTINGS.particles.life;

      for (let i = 0; i < N; i++) {
        const age = t - birth[i];
        if (age >= life) {
          respawn(i, t, beat);
          continue;
        }

        vel[i*3+0] += acc[i*3+0] * dt;
        vel[i*3+1] += acc[i*3+1] * dt;
        vel[i*3+2] += acc[i*3+2] * dt;

        pos[i*3+0] += vel[i*3+0] * dt;
        pos[i*3+1] += vel[i*3+1] * dt;
        pos[i*3+2] += vel[i*3+2] * dt;
      }
      pGeo.attributes.position.needsUpdate = true;

      stars.rotation.y = t * 0.02;
      stars.rotation.x = t * 0.01;

      controls.update();
      composer.render();
      requestAnimationFrame(tick);
    }
    tick();

    // ----------------------------
    // Resize
    // ----------------------------
    window.addEventListener("resize", () => {
      const w = window.innerWidth, h = window.innerHeight;
      camera.aspect = w / h;
      camera.updateProjectionMatrix();
      renderer.setSize(w, h);
      composer.setSize(w, h);
      uniforms.uPixelRatio.value = renderer.getPixelRatio();
    });
  </script>
</body>
</html>